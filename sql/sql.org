#+TITLE: Structured Query Language(SQL)
#+AUTHOR: Compro Prasad
* Introduction
  =SQL= is the interface for communicating to a binary file
  which is called a =database= in terms of =SQL=. So, keep in
  mind that if you change the binary file using an editor like
  [[http://hexedit.com/][hexedit]] then you could run into problems. So, don't mess
  with such kinds of files on your computer.\\
  A *database* is further divided into *tables*. Tables are further
  divided into two categories: *columns* and *rows*.\\
  It also has concepts of =RDBMS= in which you can link two
  distinct tables using similar columns in each of them. This
  can create a pretty huge relationships just like in the real world.\\
  Please make sure a =SQL= is installed on your machine before
  starting this tutorial.
* Basics
** Logging in
   It is necessary to login to access the whole/part of your
   =SQL=. Now you would say that there is no use of login. But
   what if the frontend developer of [[https://facebook.com][Facebook]] gets into the
   database and steals information of everybody.\\
   So, there is a concept of users in =SQL=. This removes the
   necessity of having different things in the same place.
   Instead, =SQL= just puts everything in the same place and
   permits the specific user to the specific information.

   Here, is a simple command for logging into =SQL= using
   *tom* as the username:
   #+BEGIN_SRC sh
   mysql -u tom -p
   #+END_SRC
   After pressing =RETURN= mysql would ask for a password.
   Enter your password and you are good to go.

   Note: During the time of installation the default user is *root*.
** What is a query?
   Query is a successful statement in =SQL= that gets a job done
   by the end user. It can be creating tables or inserting values
   or modifying values etc. The following are some examples of
   queries in =MySQL=:
   #+NAME: sql-query-examples
   #+BEGIN_SRC sql
   create table information(column1 int);
   use login_db;
   select 1+2 from dual;
   #+END_SRC
** Accessing Databases/Schemas
   Now, since you have logged in you have the control over what
   you have access to. You may not have been permitted to access
   even a single database. To see the schemas run this query:
   #+BEGIN_SRC sql
   show databases;
   #+END_SRC
** Accessing Table
   Don't you know tables?!
   There can be many tables inside a database. Thats enough
   introduction to tables in =SQL=
   #+BEGIN_SRC sql
   show tables from information_schema;
   #+END_SRC
   Replace *information_schema* with the database of your
   choice.\\
   You can also use:
   #+BEGIN_SRC sql
   show tables;
   #+END_SRC
   when you are using a specific database. See [[*Using databases][Using databases]].
** Accessing columns
   #+BEGIN_SRC sql
   show columns from information_schema.collations;
   #+END_SRC
   It is of the form =<database>.<table>=.\\
   Want a shorter form? Use the following approach:
   #+BEGIN_SRC sql
   describe information_schema.collations;
   #+END_SRC
*** Most used types of columns:
	| Type       | Description                            |
	|------------+----------------------------------------|
	| char(n)    | A string of characters of length =n=.  |
	|            | Same memory consumption for different  |
	|            | strings.                               |
	| varchar(n) | A string of characters of length =n=.  |
	|            | Memory consumption according to length |
	| int        | An integer field                       |
	| bigint     | An integer field with a large range    |
	| date       | A date of the form =YYYY-MM-DD=        |
	| datetime   | A field addressing a date and time     |
	|            | value.                                 |
** Using databases
   Databases are less in comparison to the tables in
   each database. Therefore, writing =<database>.<table>=
   can be a bit tedious. So, there is a feature in sql
   and that is using a database:
   #+BEGIN_SRC sql
   use information_schema;
   #+END_SRC
   You can now see columns using:
   #+BEGIN_SRC sql
   describe collations;
   #+END_SRC
   Since you are using the database, you cannot operate
   on a table thats inside another database using a normal
   syntax.
   But you can do two things outside the database. 
   They are:
   #+BEGIN_SRC sql
   show databases;
   use performance_schema;
   #+END_SRC
   Here *performance_schema* can be another database you
   would like to use.
   From now on it will be assumed that you are using a
   database and then the respective query can be run after
   that.
** Accessing rows
   See all rows and columns from a table:
   #+BEGIN_SRC sql
   select * from collations;
   #+END_SRC
   Filter specific set of rows from a table:
   #+BEGIN_SRC sql
   select is_default, sortlen from collations;
   #+END_SRC
   Filter specific set of rows and columns from a table:
   #+BEGIN_SRC sql
   select is_default, sortlen from collations where id < 50 and is_default='Yes';
   #+END_SRC
* Creating
** Databases
   #+BEGIN_SRC sql
   create database login_db;
   #+END_SRC
** Tables
*** Basic table
	#+BEGIN_SRC sql -i
create table info(
	username varchar(20),
	login_time timestamp,
	id bigint
);
	#+END_SRC
	=info= is the name of the table to be created. Then
	comes =username= which is the name of the field/column.
	It is of type =varchar(20)=(see table in [[*Most used types of columns:][columns mostly used]]).
	A similar approach is followed for every column. First
	the name of the column then the type of field.
*** =NOT NULL= contraint
	By default you can insert =NULL= values in any
	field. But if a field has to has a value then
	a =NOT NULL= contraint has to be added like:
	#+BEGIN_SRC sql -i
create table info(
    username varchar(20),
    login_time timestamp not null,
    id bigint not null
);  
	#+END_SRC
	You would get an error while doing that. See
	[[*Tables][Droping Tables]] and rerun the above query.\\
	The above query will prevent login_time and id
	from having =NULL= values.
*** =UNIQUE= contraint
	What if you wanted to create a field that had
	unique values. For example, [[https://mail.google.com][Gmail]] uses this to
	identify whether a user has already created an
	account using the same e-mail.\\
	But not all fields must be unique. For example,
	you may find friends with same name on [[https://www.facebook.com][Facebook]].
	And if [[https://www.facebook.com][Facebook]] used =UNIQUE= contraint on the
	name of the users then it would be pretty awkward.
	#+BEGIN_SRC sql -i
create table info(
	username varchar(20),
	login_time timestamp not null,
	id bigint not null unique
);
	#+END_SRC
* Droping
  Droping is same as deleting/removing
** Tables
   #+BEGIN_SRC sql
   drop table info;
   #+END_SRC
